name: Build & Package Marvell AQC107 2.5.12 Driver

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      # 模式選擇：預設機型或自訂參數
      build_mode:
        description: "構建模式 (preset=預設機型 / custom=自訂參數)"
        required: true
        type: choice
        options:
          - "preset"
          - "custom"
        default: "preset"
      
      # === 預設模式：快速選擇常見機型 ===
      preset_model:
        description: "預設機型 (僅 preset 模式有效)"
        required: false
        type: choice
        options:
          - "DS1621+ (v1000, DSM 7.2)"        # 2021 年 16xx 系列
          - "DS1821+ (v1000, DSM 7.2)"        # 2021 年 18xx 系列
          - "DS1821+ (v1000nk, DSM 7.3)"
          - "RS2821RP+ (v1000, DSM 7.2)"      # 2021 年 RS 系列
          - "DS1522+ (r1000nk, DSM 7.3)"      # 2022 年 15xx 系列
          - "DS423+ (geminilakenk, DSM 7.3)"  # 2023 年 4xx 系列
          - "DS723+ (r1000nk, DSM 7.3)"       # 2023 年 7xx 系列
          - "DS923+ (r1000nk, DSM 7.3)"       # 2023 年 9xx 系列
          - "DS224+ (geminilakenk, DSM 7.3)"  # 2024 年 2xx 系列
          - "DS1825+ (v1000nk, DSM 7.3)"      # 2025 年 18xx 系列
          - "DS925+ (v1000nk, DSM 7.3)"       # 2025 年 9xx 系列
        default: "DS1821+ (v1000, DSM 7.2)"
      
      # === 自訂模式：完全客製化參數 ===
      dsm_ver_full:
        description: "完整 DSM build (僅 custom 模式，例: 7.3.1-86003)"
        required: false
        default: "7.2.2-72806-4"
        type: string
      device_list:
        description: "機型清單，逗號分隔 (僅 custom 模式，例: ds1821plus,ds923plus)"
        required: false
        default: "ds1821plus"
        type: string
      cpu_series_list:
        description: "CPU 系列，逗號分隔 (僅 custom 模式，例: v1000,r1000nk)"
        required: false
        default: "v1000"
        type: string
      arch_list:
        description: "架構清單，逗號分隔 (僅 custom 模式，例: x86_64)"
        required: false
        default: "x86_64"
        type: string

env:
  PKG_NAME: "atlantic"
  PKG_VERSION: "2.5.12"
  PKG_SOURCE_URL: "https://www.marvell.com/content/dam/marvell/en/drivers/07-18-24_Marvell_Linux_2.5.12.zip"
  PKG_SOURCE_TARGET_FILE: "atlantic.tar.gz"
  NAS_CPU_LIST_URL: "https://kb.synology.com/en-global/DSM/tutorial/What_kind_of_CPU_does_my_NAS_have"
  BASE_URL: "https://global.synologydownload.com/download"
  BASE_TC_URL: "https://global.synologydownload.com/download/ToolChain"
  ARCHIVE_URL: "https://archive.synology.com/download"
  ARCHIVE_TC_URL: "https://archive.synology.com/download/ToolChain"
  ARCHIVE_OS_URL: "https://archive.synology.com/download/Os/DSM"
  SPKSRC_REPO: "https://github.com/SynoCommunity/spksrc.git"
  
  # 預設機型配置映射表 (JSON 格式)
  # 排序規則：年代 (16→18→22→23→24→25) → DSM 版本 (7.2→7.3)
  # DSM 版本說明：
  #   - DSM 7.2: 使用 7.2.2-72806-4 (最新穩定版，2025-11-15)
  #   - DSM 7.3: 使用 7.3.1-86003 (⚠️ 工具鏈尚未釋出，暫時無法構建)
  #   - 關鍵：工具鏈 URL 使用 build number (7.2-72806)，而非完整版本號
  #   - 相容性：7.2.x-72806-y 所有子版本使用相同工具鏈，驅動通用
  PRESET_CONFIGS: |
    {
      "DS1621+ (v1000, DSM 7.2)": {"device": "ds1621plus", "cpu_series": "v1000", "arch": "x86_64", "dsm_ver": "7.2.2-72806-4"},
      "DS1821+ (v1000, DSM 7.2)": {"device": "ds1821plus", "cpu_series": "v1000", "arch": "x86_64", "dsm_ver": "7.2.2-72806-4"},
      "DS1821+ (v1000nk, DSM 7.3)": {"device": "ds1821plus", "cpu_series": "v1000nk", "arch": "x86_64", "dsm_ver": "7.3.1-86003"},
      "RS2821RP+ (v1000, DSM 7.2)": {"device": "rs2821rpplus", "cpu_series": "v1000", "arch": "x86_64", "dsm_ver": "7.2.2-72806-4"},
      "DS1522+ (r1000nk, DSM 7.3)": {"device": "ds1522plus", "cpu_series": "r1000nk", "arch": "x86_64", "dsm_ver": "7.3.1-86003"},
      "DS423+ (geminilakenk, DSM 7.3)": {"device": "ds423plus", "cpu_series": "geminilakenk", "arch": "x86_64", "dsm_ver": "7.3.1-86003"},
      "DS723+ (r1000nk, DSM 7.3)": {"device": "ds723plus", "cpu_series": "r1000nk", "arch": "x86_64", "dsm_ver": "7.3.1-86003"},
      "DS923+ (r1000nk, DSM 7.3)": {"device": "ds923plus", "cpu_series": "r1000nk", "arch": "x86_64", "dsm_ver": "7.3.1-86003"},
      "DS224+ (geminilakenk, DSM 7.3)": {"device": "ds224plus", "cpu_series": "geminilakenk", "arch": "x86_64", "dsm_ver": "7.3.1-86003"},
      "DS1825+ (v1000nk, DSM 7.3)": {"device": "ds1825plus", "cpu_series": "v1000nk", "arch": "x86_64", "dsm_ver": "7.3.1-86003"},
      "DS925+ (v1000nk, DSM 7.3)": {"device": "ds925plus", "cpu_series": "v1000nk", "arch": "x86_64", "dsm_ver": "7.3.1-86003"}
    }
  
  # 資源網址 (2025-11-15 更新)
  # - ToolChain GPL Source: https://archive.synology.com/download/ToolChain/Synology%20NAS%20GPL%20Source/
  # - ToolChain Toolchain: https://archive.synology.com/download/ToolChain/toolchain/
  # - Marvell Downloads: https://www.marvell.com/support/downloads.html
  # DS1821+ 7.2-72806 範例
  # - ToolChain : https://global.synologydownload.com/download/ToolChain/toolchain/7.2-72806/Intel%20x86%20Linux%204.4.302%20%28V1000%29/v1000-gcc1220_glibc236_x86_64-GPL.txz
          
jobs:
  init:
    runs-on: ubuntu-latest
    steps:
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Generate matrix from inputs
        id: gen
        run: |
          set -e
          
          # Push 事件：使用預設配置
          if [[ "$GITHUB_EVENT_NAME" == "push" ]]; then
            printf 'matrix=%s\n' '[{"device":"ds1821plus","cpu_series":"v1000","arch":"x86_64","dsm_ver":"7.2.2-72806-4"}]' >> "$GITHUB_OUTPUT"
            printf 'dsm_ver_full=%s\n' "7.2.2-72806-4" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # Workflow_dispatch: 根據模式處理
          BUILD_MODE="${{ inputs.build_mode }}"
          
          if [[ "$BUILD_MODE" == "preset" ]]; then
            # ===== 預設模式：從映射表解析 =====
            PRESET_MODEL="${{ inputs.preset_model }}"
            echo "Using preset model: $PRESET_MODEL"
            
            # 解析 JSON 配置
            CONFIG=$(echo '${{ env.PRESET_CONFIGS }}' | jq -r --arg model "$PRESET_MODEL" '.[$model]')
            
            if [[ "$CONFIG" == "null" || -z "$CONFIG" ]]; then
              echo "::error::Invalid preset model: $PRESET_MODEL"
              exit 1
            fi
            
            DEVICE=$(echo "$CONFIG" | jq -r '.device')
            CPU_SERIES=$(echo "$CONFIG" | jq -r '.cpu_series')
            ARCH=$(echo "$CONFIG" | jq -r '.arch')
            DSM_VER=$(echo "$CONFIG" | jq -r '.dsm_ver')
            
            # 產生單一機型 matrix
            MATRIX=$(jq -n \
              --arg d "$DEVICE" \
              --arg c "$CPU_SERIES" \
              --arg a "$ARCH" \
              --arg v "$DSM_VER" \
              '[{device: $d, cpu_series: $c, arch: $a, dsm_ver: $v}]')
            
            printf 'matrix=%s\n' "$MATRIX" >> "$GITHUB_OUTPUT"
            printf 'dsm_ver_full=%s\n' "$DSM_VER" >> "$GITHUB_OUTPUT"
            
          else
            # ===== 自訂模式：解析逗號分隔清單 =====
            IFS=',' read -ra DEVICES <<< "${{ inputs.device_list }}"
            IFS=',' read -ra CPUS    <<< "${{ inputs.cpu_series_list }}"
            IFS=',' read -ra ARCHS   <<< "${{ inputs.arch_list }}"
            DSM_VER="${{ inputs.dsm_ver_full }}"
            
            # 驗證陣列長度一致
            if [[ ${#DEVICES[@]} -ne ${#CPUS[@]} || ${#DEVICES[@]} -ne ${#ARCHS[@]} ]]; then
              echo "::error::device_list, cpu_series_list, arch_list 長度必須相同"
              exit 1
            fi
            
            # 建立 matrix
            MATRIX=$(jq -n \
              --argjson d "$(printf '%s\n' "${DEVICES[@]}" | jq -R . | jq -s .)" \
              --argjson c "$(printf '%s\n' "${CPUS[@]}"    | jq -R . | jq -s .)" \
              --argjson a "$(printf '%s\n' "${ARCHS[@]}"   | jq -R . | jq -s .)" \
              --arg v "$DSM_VER" \
              '[range(0; ($d|length)) | {
                device:     $d[.],
                cpu_series: $c[.],
                arch:       $a[.],
                dsm_ver:    $v
              }]')
            
            printf 'matrix=%s\n' "$MATRIX" >> "$GITHUB_OUTPUT"
            printf 'dsm_ver_full=%s\n' "$DSM_VER" >> "$GITHUB_OUTPUT"
          fi
          
          echo "Generated matrix:"
          echo "$MATRIX" | jq .
    outputs:
      matrix: ${{ steps.gen.outputs.matrix }}
      dsm_ver_full: ${{ steps.gen.outputs.dsm_ver_full }}

  build:
    runs-on: ubuntu-latest
    needs: init
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJSON(needs.init.outputs.matrix) }}
    name: Build - ${{ matrix.device }} (${{ matrix.dsm_ver }})
    env:
      DEVICE: ${{ matrix.device }}
      CPU_SERIES: ${{ matrix.cpu_series }}
      ARCH: ${{ matrix.arch }}
      DSM_VER_FULL: ${{ matrix.dsm_ver }}
      DRIVER_DIR: ${{ github.workspace }}/driver-${{ matrix.device }}
    steps:
      # —————————— 準備 ——————————
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize Folder
        run: |
          # ————— 建立目錄 —————
          mkdir -p "${DRIVER_DIR}"
          mkdir -p "${DRIVER_DIR}/${PKG_NAME}"

      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y xz-utils bc build-essential wget unzip git

      - name: Get NAS specific information
        run: |
          set -ex

          # 1) plus 回復原始 + (ds1821plus → ds1821+ / rs2423rpplus → rs2423rp+)
          MODEL="$(echo "$DEVICE" | sed 's/plus$/+/')"

          # 2) 驗證 MODEL 與 CPU_SERIES (已移除，因為網頁格式可能已改變)
          # CPU_SERIES_FIND=$(curl -s "$NAS_CPU_LIST_URL" \
          #   | grep -ioP "<td[^>]*>${MODEL//+/\\+}</td>.*?<td[^>]*>\\K[^<]+" \
          #   | head -1)
          # if [ -n "$CPU_SERIES_FIND" ] && [ "$CPU_SERIES_FIND" != "$CPU_SERIES" ]; then
          #   echo "Warning: CPU_SERIES for '$MODEL' 應為 '$CPU_SERIES_FIND'"
          #   CPU_SERIES="$CPU_SERIES_FIND"
          #   echo "CPU_SERIES=$CPU_SERIES" >> "$GITHUB_ENV"
          # fi
          # CPU_SERIES_FINDED=$(wget -qO- "$NAS_CPU_LIST_URL" \
          #   | grep -i -A1 -e "<td>$MODEL</td>" \
          #   | tail -1 \
          #   | sed 's/.*<td>\(.*\)<\/td>.*/\1/')
          # if [ -z "$CPU_SERIES_FINDED" ]; then
          #   echo "Error: Could not find CPU_SERIES for '$MODEL'. Please check the input or device in build_json."
          #   echo "::warning::CPU_SERIES for $MODEL not found, skip validation"
          # fi
          # if !$CPU_SERIES_FINDED && [ "$CPU_SERIES_FINDED" != "$CPU_SERIES" ]; then
          #   echo "Warning: CPU_SERIES for '$MODEL' should be '$CPU_SERIES_FINDED'. Please check the input or device in build_json."
          #   CPU_SERIES=${CPU_SERIES_FINDED}
          #   echo "CPU_SERIES=$CPU_SERIES" >> $GITHUB_ENV
          # fi

          # 3) 繼續宣告 機型 別名
          # ds1821+ → ds
          MODEL_SERIES="$(echo "${MODEL}" | sed 's/^\([a-z][a-z]\).*/\1/')"
          # ds1821+ → 1821+
          MODEL_SUB="$(echo "${MODEL}" | sed 's/^[a-z][a-z]//')"
          # ds1821+ → DS1821+ / ds416play → DS416play
          MODEL_UPPER="$(echo "${MODEL_SERIES}" | tr '[:lower:]' '[:upper:]')${MODEL_SUB}"
          echo "MODEL=${MODEL}" >> $GITHUB_ENV

          # 4) 驗證 DSM_VER_FULL (https://archive.synology.com/download/Os/DSM)
          OS_INDEX=$(curl -fsSL "$ARCHIVE_OS_URL")
          if ! grep -Fq "$DSM_VER_FULL" <<< "$OS_INDEX"; then
            echo "Error: ${DSM_VER_FULL} is not exist. Will use latest version."
            # DSM_VER_FULL=$(echo "$OS_INDEX" | grep -oE "[6-9]\.[0-9](\.[0-9])?-[0-9]+(-[0-9]+)?" | head -n1)
            DSM_VER_FULL=$(grep -oE '[6-9]\.[0-9](\.[0-9])?-[0-9]+(-[0-9]+)?' <<< "$OS_INDEX" | head -1)
            echo "DSM_VER_FULL=$DSM_VER_FULL" >> $GITHUB_ENV
          fi

          # 5) 計算 DSM 版本別名
          # Check DSM_VER_FULL is major version or minor version
          # 7.2.2-72806 is major version / 7.2.2-72806-3 is minor version
          IS_MAJOR_VER=false
          if [[ $(grep -o '-' <<< "$DSM_VER_FULL" | wc -l) -eq 2 ]]; then
            IS_MAJOR_VER=false
          else
            IS_MAJOR_VER=true
          fi
          IFS='-' read -r DSM_MAIN_VER DSM_VER DSM_PATCH_VER <<< "$DSM_VER_FULL"
          DSM_PATCH_VER=${DSM_PATCH_VER:-}      # 沒 patch 時給空
          if [ -z "$DSM_PATCH_VER" ]; then
            DSM_TAG="${DSM_MAIN_VER}-${DSM_VER}"   # 7.2-72806
          else
            DSM_TAG="${DSM_MAIN_VER%.*}-${DSM_VER}"  # 7.2-72806
          fi
          # if $IS_MAJOR_VER; then
          #   # 7.2.2-72806 = DSM_VER_FULL = DSM_MAIN_VER-DSM_VER
          #   # 7.2-72806 = DSM_VER_FULL_SHORT = DSM_MAIN_MAJOR_VER-DSM_VER
          #   DSM_MAIN_VER="${DSM_VER_FULL%-*}" # 7.2.2
          #   DSM_VER="${DSM_VER_FULL#*-}" # 72806
          #   DSM_VER_FULL_SHORT="${DSM_MAIN_VER}-${DSM_VER}" # 7.2-72806
          #   DSM_TAG="${DSM_VER_FULL_SHORT}" # 7.2-72806
          #   DSM_PATCH_VER=""
          # else
          #   # 7.2.2-72806-3 = DSM_VER_FULL = DSM_MAIN_VER-DSM_VER-DSM_PATCH_VER
          #   # 7.2-72806-3 = DSM_VER_FULL_SHORT = DSM_MAIN_MAJOR_VER-DSM_VER-DSM_PATCH_VER
          #   DSM_MAIN_VER="${DSM_VER_FULL%-*}" # 7.2.2
          #   DSM_VER="${DSM_VER_FULL#*-}" # 72806
          #   DSM_VER_FULL_SHORT="${DSM_MAIN_VER%.*}-${DSM_VER}-${DSM_PATCH_VER}" # 7.2-72806-3
          #   DSM_TAG="${DSM_VER_FULL%.*}-${DSM_VER}" # 7.2-72806
          #   DSM_PATCH_VER="${DSM_VER_FULL_SHORT##*-}"# 3
          # fi

          echo "DSM_TAG=${DSM_TAG}" >> $GITHUB_ENV

          # 6) 驗證 $ARCH (藉由 TOOLCHAIN_WEBFOLDER)
          TOOLCHAIN_WEBFOLDER="${ARCHIVE_TC_URL}/toolchain/${DSM_TAG}"

          # 7) 檢查目錄是否存在？
          if ! curl -fsI "$TOOLCHAIN_WEBFOLDER/" >/dev/null ; then
            echo "::warning::$TOOLCHAIN_WEBFOLDER 不存在，跳過此機種"
            exit 1
          fi

          TOOLCHAIN_WEBFOLDER_CONTENT=$(curl -sL "${TOOLCHAIN_WEBFOLDER}/")
          # TOOLCHAIN_FILE_NAME=$(echo "$TOOLCHAIN_WEBFOLDER_CONTENT" |
          #                     grep -oE "${CPU_SERIES}-gcc[0-9_]+_[^_]+_(x86_64|armv8|armv7)-GPL.txz" |
          #                     head -n1)
          # Check if TOOLCHAIN_URL is already available (from previous run or cache)
          if [ -n "$TOOLCHAIN_URL" ]; then
            echo "TOOLCHAIN_URL already available: $TOOLCHAIN_URL"
            # Try to extract ARCH from existing URL
            TEST_ARCH=$(echo "$TOOLCHAIN_URL" | sed -E 's/.*_(x86_64|armv8|armv7)-GPL\.txz/\1/')
            echo "DEBUG: Extracted TEST_ARCH from URL: '$TEST_ARCH'"
            if [ -n "$TEST_ARCH" ] && [ "$TEST_ARCH" != "$TOOLCHAIN_URL" ]; then
              echo "DEBUG: Using TEST_ARCH from URL: $TEST_ARCH"
              ARCH_FINDED="$TEST_ARCH"
            fi
          fi

          TOOLCHAIN_FILE_NAME=$(echo "$TOOLCHAIN_WEBFOLDER_CONTENT" |
                                grep -oE "${CPU_SERIES}-gcc[0-9_]+.*_(x86_64|armv8|armv7)-GPL\.txz" |
                                head -n1)
          echo "CPU_SERIES: $CPU_SERIES"
          echo "TOOLCHAIN_WEBFOLDER_CONTENT preview:"
          echo "$TOOLCHAIN_WEBFOLDER_CONTENT" | head -20
          echo "TOOLCHAIN_FILE_NAME: $TOOLCHAIN_FILE_NAME"

          # If the specific pattern doesn't match, try a more general pattern
          if [ -z "$TOOLCHAIN_FILE_NAME" ]; then
            echo "Trying more general pattern..."
            TOOLCHAIN_FILE_NAME=$(echo "$TOOLCHAIN_WEBFOLDER_CONTENT" |
                                  grep -oE "${CPU_SERIES}.*\.txz" |
                                  head -n1)
            echo "TOOLCHAIN_FILE_NAME (general): $TOOLCHAIN_FILE_NAME"
          fi

          # If still no TOOLCHAIN_FILE_NAME, create a fallback for known CPU series
          if [ -z "$TOOLCHAIN_FILE_NAME" ]; then
            echo "No TOOLCHAIN_FILE_NAME found, using fallback for CPU_SERIES: $CPU_SERIES"
            case "$CPU_SERIES" in
              # DSM 7.2 (Kernel 4.4.302)
              v1000)
                TOOLCHAIN_FILE_NAME="v1000-gcc1220_glibc236_x86_64-GPL.txz"
                ;;
              braswell)
                TOOLCHAIN_FILE_NAME="braswell-gcc493_glibc220_x86_64-GPL.txz"
                ;;
              avoton)
                TOOLCHAIN_FILE_NAME="avoton-gcc493_glibc220_x86_64-GPL.txz"
                ;;
              # DSM 7.3 (Kernel 5.10.55) - nk series
              v1000nk)
                TOOLCHAIN_FILE_NAME="v1000nk-gcc1220_glibc236_x86_64-GPL.txz"
                ;;
              r1000nk)
                TOOLCHAIN_FILE_NAME="r1000nk-gcc1220_glibc236_x86_64-GPL.txz"
                ;;
              geminilakenk)
                TOOLCHAIN_FILE_NAME="geminilakenk-gcc1220_glibc236_x86_64-GPL.txz"
                ;;
              *)
                echo "::error::Unknown CPU_SERIES $CPU_SERIES and no toolchain file found"
                exit 1
                ;;
            esac
            echo "TOOLCHAIN_FILE_NAME (fallback): $TOOLCHAIN_FILE_NAME"
          fi

          if [ -z "$TOOLCHAIN_FILE_NAME" ]; then
            echo "::warning::找不到 $CPU_SERIES 的 toolchain 於 $DSM_TAG，跳過此機種"
            exit 1
          fi

          # ARCH_FINDED=$(echo "$TOOLCHAIN_FILE_NAME" | sed -E 's/.*_([^_]+)-GPL.txz/\1/')
          # echo "$CPU_SERIES → ARCH FINDED: $ARCH_FINDED"
          # ---------- ARCH_FINDED ----------
          # Try multiple extraction methods
          echo "DEBUG: Starting ARCH extraction from TOOLCHAIN_FILE_NAME='$TOOLCHAIN_FILE_NAME'"
          ARCH_FINDED=$(echo "$TOOLCHAIN_FILE_NAME" | sed -E 's/.*_(x86_64|armv8|armv7)-GPL\.txz/\1/')
          echo "DEBUG: First extraction attempt: ARCH_FINDED='$ARCH_FINDED'"
          if [ -z "$ARCH_FINDED" ] || [ "$ARCH_FINDED" = "$TOOLCHAIN_FILE_NAME" ]; then
            ARCH_FINDED=$(echo "$TOOLCHAIN_FILE_NAME" | sed -E 's/.*_([^-]+)-GPL\.txz/\1/')
            echo "DEBUG: Second extraction attempt: ARCH_FINDED='$ARCH_FINDED'"
          fi
          echo "Toolchain filename: $TOOLCHAIN_FILE_NAME"
          echo "Extracted ARCH: $ARCH_FINDED"

          # If ARCH extraction failed, try alternative methods
          if [ -z "$ARCH_FINDED" ] || [ "$ARCH_FINDED" = "$TOOLCHAIN_FILE_NAME" ] || [[ "$ARCH_FINDED" =~ ^[0-9]+$ ]]; then
            echo "ARCH extraction failed or returned invalid value ($ARCH_FINDED), trying alternative method..."
            # Extract from URL first (most reliable)
            if [ -n "$TOOLCHAIN_URL" ]; then
              ARCH_FINDED=$(echo "$TOOLCHAIN_URL" | sed -E 's/.*_(x86_64|armv8|armv7)-GPL\.txz/\1/')
              echo "ARCH from URL: $ARCH_FINDED"
            fi
            # If still no ARCH, try to extract from filename with different pattern
            if [ -z "$ARCH_FINDED" ] && [ -n "$TOOLCHAIN_FILE_NAME" ]; then
              ARCH_FINDED=$(echo "$TOOLCHAIN_FILE_NAME" | sed -E 's/.*_(x86_64|armv8|armv7).*/\1/')
              echo "ARCH from filename fallback: $ARCH_FINDED"
            fi
            # Try extracting from URL with different pattern
            if [ -z "$ARCH_FINDED" ] && [ -n "$TOOLCHAIN_URL" ]; then
              ARCH_FINDED=$(echo "$TOOLCHAIN_URL" | sed -E 's/.*_([^-]+)-GPL\.txz/\1/')
              echo "ARCH from URL fallback: $ARCH_FINDED"
            fi
            # Last resort: hardcode based on known CPU series
            if [ -z "$ARCH_FINDED" ]; then
              case "$CPU_SERIES" in
                # x86_64 架構 CPU
                v1000|v1000nk|r1000|r1000nk|braswell|avoton|geminilake|geminilakenk|apollolake|broadwell|denverton|purley|kvmx64)
                  ARCH_FINDED="x86_64"
                  ;;
                # ARM64 架構 CPU
                rtd1296|rtd1619b|armada37xx|epyc7002)
                  ARCH_FINDED="armv8"
                  ;;
                # ARM 架構 CPU
                armada38x|armada370)
                  ARCH_FINDED="armv7"
                  ;;
                *)
                  ARCH_FINDED="x86_64"
                  ;;
              esac
              echo "ARCH from CPU_SERIES fallback: $ARCH_FINDED"
            fi
            # Final fallback: if still no ARCH, check if URL contains known patterns
            if [ -z "$ARCH_FINDED" ] && [ -n "$TOOLCHAIN_URL" ]; then
              if [[ "$TOOLCHAIN_URL" == *x86_64* ]]; then
                ARCH_FINDED="x86_64"
              elif [[ "$TOOLCHAIN_URL" == *armv8* ]]; then
                ARCH_FINDED="armv8"
              elif [[ "$TOOLCHAIN_URL" == *armv7* ]]; then
                ARCH_FINDED="armv7"
              fi
              echo "ARCH from URL pattern match: $ARCH_FINDED"
            fi
          fi

          if [ -z "$ARCH_FINDED" ]; then
            echo "::error::無法由檔名解析架構，檔名=$TOOLCHAIN_FILE_NAME"
            exit 1
          fi

          # Final validation: ensure ARCH_FINDED is valid
          if [[ "$ARCH_FINDED" =~ ^[0-9]+$ ]] || [ -z "$ARCH_FINDED" ]; then
            echo "::warning::ARCH_FINDED is invalid ($ARCH_FINDED), forcing to x86_64 for v1000 CPU series"
            ARCH_FINDED="x86_64"
          fi

          # Validate ARCH_FINDED
          case "$ARCH_FINDED" in
            x86_64|armv8|armv7)
              echo "Valid architecture detected: $ARCH_FINDED"
              ;;
            *)
              echo "::warning::Unexpected architecture: $ARCH_FINDED, proceeding anyway"
              ;;
          esac

          if [ "$ARCH_FINDED" != "$ARCH" ]; then
            echo "Warning: ARCH for '$MODEL' should be '$ARCH_FINDED'. Please check the input or device in build_json."
            ARCH=${ARCH_FINDED}
            echo "ARCH=$ARCH" >> $GITHUB_ENV
          fi
          echo "ARCH_FINDED=$ARCH_FINDED" >> $GITHUB_ENV

          # 將 ARCH 轉換為 kernel 預期的格式
          echo "DEBUG: About to convert ARCH_FINDED='$ARCH_FINDED' to KERNEL_ARCH"
          case "$ARCH_FINDED" in
            x86_64)
              KERNEL_ARCH="x86"
              echo "DEBUG: Matched x86_64, setting KERNEL_ARCH=x86"
              ;;
            armv8)
              KERNEL_ARCH="arm64"
              echo "DEBUG: Matched armv8, setting KERNEL_ARCH=arm64"
              ;;
            armv7)
              KERNEL_ARCH="arm"
              echo "DEBUG: Matched armv7, setting KERNEL_ARCH=arm"
              ;;
            *)
              echo "DEBUG: ARCH_FINDED='$ARCH_FINDED' did not match any case, going to fallback logic"
              # If ARCH_FINDED doesn't match known patterns, try to extract from it
              if [[ "$ARCH_FINDED" == *x86* ]]; then
                KERNEL_ARCH="x86"
                echo "DEBUG: Fallback: found x86 in ARCH_FINDED, setting KERNEL_ARCH=x86"
              elif [[ "$ARCH_FINDED" == *arm64* ]] || [[ "$ARCH_FINDED" == *armv8* ]]; then
                KERNEL_ARCH="arm64"
                echo "DEBUG: Fallback: found arm in ARCH_FINDED, setting KERNEL_ARCH=arm64"
              elif [[ "$ARCH_FINDED" == *arm* ]]; then
                KERNEL_ARCH="arm"
                echo "DEBUG: Fallback: found arm in ARCH_FINDED, setting KERNEL_ARCH=arm"
              else
                echo "::warning::Unknown architecture $ARCH_FINDED, attempting to use it directly as kernel arch"
                KERNEL_ARCH="$ARCH_FINDED"
                echo "DEBUG: Using ARCH_FINDED directly: KERNEL_ARCH='$KERNEL_ARCH'"
                # If it's still invalid, default to x86
                if [[ "$KERNEL_ARCH" =~ ^[0-9]+$ ]] || [ -z "$KERNEL_ARCH" ]; then
                  echo "::warning::Invalid kernel arch $KERNEL_ARCH, defaulting to x86"
                  KERNEL_ARCH="x86"
                  echo "DEBUG: Invalid KERNEL_ARCH, defaulting to x86"
                fi
              fi
              ;;
          esac
          echo "DEBUG: Final KERNEL_ARCH='$KERNEL_ARCH'"
          
          # Safety check: ensure KERNEL_ARCH is never empty
          if [ -z "$KERNEL_ARCH" ]; then
            echo "::warning::KERNEL_ARCH is empty, forcing to x86"
            KERNEL_ARCH="x86"
          fi
          echo "=== Architecture Summary ==="
          echo "Matrix ARCH: $ARCH"
          echo "Detected ARCH: $ARCH_FINDED"
          echo "Kernel ARCH: $KERNEL_ARCH"
          echo "TOOLCHAIN_FILE_NAME: $TOOLCHAIN_FILE_NAME"
          echo "TOOLCHAIN_URL: $TOOLCHAIN_URL"
          echo "============================"
          echo "KERNEL_ARCH=$KERNEL_ARCH" >> $GITHUB_ENV
          # Map ARCH to SPKSRC_ARCH
          case "$ARCH" in
            x86_64)
              SPKSRC_ARCH="x64"
              ;;
            x86)
              SPKSRC_ARCH="x86"
              ;;
            *)
              SPKSRC_ARCH="$ARCH"
              ;;
          esac
          echo "SPKSRC_ARCH=$SPKSRC_ARCH" >> $GITHUB_ENV
          # 8) 取下載網址方便之後下載
          # TOOLCHAIN_URL=$(echo "$TOOLCHAIN_WEBFOLDER_CONTENT" | grep -B2 "${TOOLCHAIN_FILE_NAME}" | grep -oP '<a href="\K[^"]+' | head -n1)

          TOOLCHAIN_URL=$(echo "$TOOLCHAIN_WEBFOLDER_CONTENT" \
                  | grep -B2 "$TOOLCHAIN_FILE_NAME" \
                  | grep -oP '<a href="\K[^"]+' \
                  | head -n1)
          echo "TOOLCHAIN_URL: $TOOLCHAIN_URL"
          if [ -z "$TOOLCHAIN_URL" ]; then
            echo "::warning::TOOLCHAIN_URL not found, using fallback for CPU_SERIES: $CPU_SERIES"
            case "$CPU_SERIES" in
              # DSM 7.2 (Kernel 4.4.302)
              v1000)
                TOOLCHAIN_URL="https://global.synologydownload.com/download/ToolChain/toolchain/7.2-72806/Intel%20x86%20Linux%204.4.302%20%28V1000%29/v1000-gcc1220_glibc236_x86_64-GPL.txz"
                ;;
              braswell)
                TOOLCHAIN_URL="https://global.synologydownload.com/download/ToolChain/toolchain/7.2-72806/Intel%20x86%20Linux%204.4.302%20%28Braswell%29/braswell-gcc493_glibc220_x86_64-GPL.txz"
                ;;
              avoton)
                TOOLCHAIN_URL="https://global.synologydownload.com/download/ToolChain/toolchain/7.2-72806/Intel%20x86%20Linux%204.4.302%20%28Avoton%29/avoton-gcc493_glibc220_x86_64-GPL.txz"
                ;;
              # DSM 7.3 (Kernel 5.10.55) - 需要實際 URL 驗證
              v1000nk|r1000nk|geminilakenk)
                echo "::warning::DSM 7.3 toolchain URL for $CPU_SERIES not available in fallback, may fail"
                echo "::warning::Please ensure DSM_TAG ${DSM_TAG} has toolchain available online"
                # 暫時使用可能的 URL 格式，實際使用時會從網頁動態查詢
                TOOLCHAIN_URL=""
                ;;
              *)
                echo "::error::Unknown CPU_SERIES $CPU_SERIES and no toolchain URL found"
                exit 1
                ;;
            esac
            
            if [ -n "$TOOLCHAIN_URL" ]; then
              echo "TOOLCHAIN_URL (fallback): $TOOLCHAIN_URL"
            else
              echo "::error::No fallback URL available for $CPU_SERIES, must fetch from web"
              exit 1
            fi
          fi
          echo "TOOLCHAIN_URL=$TOOLCHAIN_URL" >> "$GITHUB_ENV"

          # If TOOLCHAIN_URL is already set from previous run, use it for ARCH extraction
          if [ -n "$TOOLCHAIN_URL" ]; then
            echo "Using existing TOOLCHAIN_URL for ARCH extraction"
          fi

          # 9) 取 Kernel 版本
          # TOOLCHAIN_URL = https://global.synologydownload.com/download/ToolChain/toolchain/7.2-72806/Intel%20x86%20Linux%204.4.302%20%28V1000%29/v1000-gcc1220_glibc236_x86_64-GPL.txz
          # KERNEL_VER=$(echo "$TOOLCHAIN_URL" | sed -E 's/.*Linux%20([^%]+)%20.*/\1/')
          KERNEL_VER=$(echo "$TOOLCHAIN_URL" | sed -E 's/.*Linux%20([^%]+)%20.*/\1/')
          if [ -z "$KERNEL_VER" ]; then
            echo "::warning::無法從 TOOLCHAIN_URL 提取 Kernel 版本，使用 CPU 系列 fallback"
            # Fallback: 根據 CPU 系列設定已知的 Kernel 版本
            case "$CPU_SERIES" in
              # DSM 7.2 (Kernel 4.4.302)
              v1000)
                KERNEL_VER="4.4.302"
                ;;
              braswell)
                KERNEL_VER="4.4.302"
                ;;
              avoton)
                KERNEL_VER="4.4.302"
                ;;
              geminilake|apollolake)
                KERNEL_VER="4.4.180"
                ;;
              # DSM 7.3 (Kernel 5.10.55)
              v1000nk|r1000nk|geminilakenk)
                KERNEL_VER="5.10.55"
                ;;
              *)
                echo "::error::無法確定 CPU_SERIES $CPU_SERIES 的 Kernel 版本"
                exit 1
                ;;
            esac
            echo "使用 fallback Kernel 版本: $KERNEL_VER"
          fi
          echo "KERNEL_VER=$KERNEL_VER" >> $GITHUB_ENV

        continue-on-error: true

      - name: Extract Kernel version
        run: |
          # 宣告 KERNEL_VER_MAJOR 和 KERNEL_VER_SERIES (Extract 4 and 4.4 from 4.4.302)
          if [ -z "$KERNEL_VER" ]; then
            echo "::error::KERNEL_VER is not set, cannot extract kernel version"
            exit 1
          fi
          echo "KERNEL_VER_MAJOR=${KERNEL_VER%%.*}" >> $GITHUB_ENV
          echo "KERNEL_VER_SERIES=${KERNEL_VER%.*}" >> $GITHUB_ENV

      # —————————— 下載並解壓 ——————————
      - name: Download essential files from GitHub Repository
        run: |
          # 1) 設定 REPO_URL 並下載 aqc107.cfg
          MY_REPO_URL="https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/main"
          curl -L -o aqc107.cfg ${MY_REPO_URL}/kernel-config-append/aqc107.cfg
          if [ ! -f "aqc107.cfg" ]; then
            echo "::error::Failed to download aqc107.cfg from repository"
            exit 1
          fi
          # 2) 宣告 REPO_URL
          echo "REPO_URL=${MY_REPO_URL}" >> $GITHUB_ENV

      - name: Synology 內核原始碼 Source (25/06/11)
        run: |
          # 下載並解壓
          if [ -z "$KERNEL_VER_SERIES" ]; then
            echo "::error::KERNEL_VER_SERIES is not set, cannot download kernel source"
            exit 1
          fi
          KERNEL_SRC_FILE="linux-${KERNEL_VER_SERIES}.x.txz"
          wget -O "$KERNEL_SRC_FILE" "${BASE_TC_URL}/Synology%20NAS%20GPL%20Source/${DSM_TAG}/${CPU_SERIES}/linux-${KERNEL_VER_SERIES}.x.txz"
          if [ ! -f "$KERNEL_SRC_FILE" ]; then
            echo "::error::Failed to download kernel source file"
            exit 1
          fi
          tar xJf "$KERNEL_SRC_FILE"

      - name: Synology 交叉編譯工具鏈 ToolChain (25/06/11)
        run: |
          # 下載並解壓
          if [ -z "$TOOLCHAIN_URL" ]; then
            echo "::error::TOOLCHAIN_URL is not set, cannot download toolchain"
            exit 1
          fi
          wget -O toolchain.txz "${TOOLCHAIN_URL}"
          if [ ! -f "toolchain.txz" ]; then
            echo "::error::Failed to download toolchain file"
            exit 1
          fi
          tar xJf toolchain.txz

      - name: 驅動 Marvell AQC107 (25/06/11)
        run: |
          # 1) 下載並解壓
          if [ -z "$PKG_SOURCE_URL" ]; then
            echo "::error::PKG_SOURCE_URL is not set, cannot download driver"
            exit 1
          fi
          wget -q -O marvell.zip "${PKG_SOURCE_URL}"
          if [ ! -f "marvell.zip" ]; then
            echo "::error::Failed to download Marvell driver file"
            exit 1
          fi
          # 2) 只解出 atlantic.tar.gz
          PSTF_PATH=$(unzip -Z1 marvell.zip | grep -i -m1 -E "(^|/)${PKG_SOURCE_TARGET_FILE}$")
          unzip -j marvell.zip "${PSTF_PATH}"
          if [ ! -f "atlantic.tar.gz" ]; then
            echo "::error::Failed to extract atlantic.tar.gz from Marvell driver archive"
            exit 1
          fi
          # 3) 把 Linux/ 這一層 strip 掉
          tar -xzf atlantic.tar.gz \
              --strip-components=1 \
              -C "${DRIVER_DIR}/${PKG_NAME}"

      # —————————— 編譯 ——————————

      - name: 啟動 Synology 內核編譯功能
        run: |
          # 1) 宣告環境變數 TOOLCHAIN_DIR 和 CROSS_COMPILE
          echo "KERNEL_SRC=${PWD}/linux-${KERNEL_VER_SERIES}.x" >> $GITHUB_ENV
          echo "TOOLCHAIN_DIR=${PWD}/${ARCH_FINDED}-pc-linux-gnu/" >> $GITHUB_ENV
          # CROSS_COMPILE_PATH="${PWD}/${ARCH}-pc-linux-gnu/bin/${ARCH}-pc-linux-gnu-"
          # echo "CROSS_COMPILE_ENV=${CROSS_COMPILE_PATH}" >> $GITHUB_ENV
          echo "CROSS_COMPILE=${PWD}/${ARCH_FINDED}-pc-linux-gnu/bin/${ARCH_FINDED}-pc-linux-gnu-" >> $GITHUB_ENV
          echo "${PWD}/${ARCH_FINDED}-pc-linux-gnu/bin" >> $GITHUB_PATH     # gcc 放進 PATH

          # 2) 切換目錄
          cd linux-${KERNEL_VER_SERIES}.x

          # 3) 拷貝官方 synoconfigs 基礎 config
          cp synoconfigs/${CPU_SERIES} .config

          # 4) 用 merge_config.sh 合併你的 cfg
          scripts/kconfig/merge_config.sh .config ../aqc107.cfg
          yes "" | make oldconfig      # 自動答預設

          # 5) 修改 Makefile ( EXTRAVERSION = to EXTRAVERSION = + )
          sed -i "s/EXTRAVERSION = /EXTRAVERSION = +/g" Makefile

          # 6) 準備編譯
          echo "DEBUG: About to use KERNEL_ARCH='$KERNEL_ARCH' for kernel build"
          if [ -z "$KERNEL_ARCH" ]; then
            echo "::warning::KERNEL_ARCH is empty, setting to x86"
            KERNEL_ARCH="x86"
          fi
          export ARCH=${KERNEL_ARCH}
          echo "Building kernel with ARCH=${ARCH}"
          make clean
          # make -j$(nproc) CROSS_COMPILE=${CROSS_COMPILE_PATH} prepare
          # make -j$(nproc) CROSS_COMPILE=${CROSS_COMPILE_PATH} scripts
          make -j$(nproc) prepare
          make -j$(nproc) scripts

      - name: 編譯模組 AQC107
        run: |
          # 1) 切換目錄 
          cd ${DRIVER_DIR}/${PKG_NAME}/

          # 2) aq_compat.h 處理 page_ref_count
          FILE="${DRIVER_DIR}/${PKG_NAME}/aq_compat.h"
          if [ -f "$FILE" ]; then
            sed -i '/static inline int page_ref_count/,/^#endif/c #endif /* page_ref_count fallback removed */' "$FILE"
          else
            echo "::warning::aq_compat.h not found, skipping page_ref_count fix"
          fi

          # 3) 編譯
          if [ -z "$KERNEL_SRC" ]; then
            echo "::error::KERNEL_SRC is not set, cannot compile module"
            exit 1
          fi
          echo "DEBUG: About to use KERNEL_ARCH='$KERNEL_ARCH' for module build"
          if [ -z "$KERNEL_ARCH" ]; then
            echo "::warning::KERNEL_ARCH is empty, setting to x86"
            KERNEL_ARCH="x86"
          fi
          export ARCH=${KERNEL_ARCH}
          echo "Compiling module with ARCH=${ARCH}"
          make -j$(nproc) CROSS_COMPILE=${CROSS_COMPILE} -C ${KERNEL_SRC} M=$PWD modules

      - name: 上傳 .ko 模組為 Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PKG_NAME }}-${{ env.PKG_VERSION }}-${{ matrix.dsm_ver }}-${{ matrix.cpu_series }}-ko
          path: ${{ env.DRIVER_DIR }}/${{ env.PKG_NAME }}/*.ko
          if-no-files-found: error

      # —————————— 開始打包成 SPK ——————————
      - name: Clone spksrc 框架
        run: |
          # git clone --depth 1 ${SPKSRC_REPO} spksrc
          git clone --branch master --single-branch ${SPKSRC_REPO} spksrc

      - name: 建立 SPK 骨架 and 複製 .ko
        run: |
          # 1) 切換目錄
          cd spksrc

          # 2) 建立 driver 套件骨架目錄
          mkdir -p spk/atlantic
          mkdir -p spk/atlantic/src

          # 3) 嘗試複製我們的套件檔案到 spksrc 框架
          echo "Source directory: ${GITHUB_WORKSPACE}/packages/driver/atlantic/"
          if [ -d "${GITHUB_WORKSPACE}/packages/driver/atlantic" ]; then
            echo "Source directory exists, attempting to copy files..."
            ls -la "${GITHUB_WORKSPACE}/packages/driver/atlantic/" 2>/dev/null || echo "No files found"
            cp -r "${GITHUB_WORKSPACE}/packages/driver/atlantic/"* spk/atlantic/ 2>/dev/null && echo "SPK files copied successfully" || echo "SPK copy failed or no files to copy"
          else
            echo "::warning::Source directory does not exist"
          fi

          # 4) 檢查是否需要建立基本檔案
          if [ ! -f "spk/atlantic/Makefile" ]; then
            echo "Creating basic Makefile..."
            echo 'SPK_NAME = atlantic' > spk/atlantic/Makefile
            echo 'SPK_VERS = 2.5.12' >> spk/atlantic/Makefile
            echo 'SPK_REV = 1' >> spk/atlantic/Makefile
            echo 'DEPENDS =' >> spk/atlantic/Makefile
            echo 'MAINTAINER = your-maintainer' >> spk/atlantic/Makefile
            echo 'DESCRIPTION = Marvell AQC107 10GbE Network Driver' >> spk/atlantic/Makefile
            echo 'include ../../mk/spksrc.spk.mk' >> spk/atlantic/Makefile
          fi

          # 5) 編好的 atlantic.ko 已在 $DRIVER_DIR/atlantic/atlantic.ko
          if [ -z "$KERNEL_VER" ]; then
            echo "::error::KERNEL_VER is not set"
            exit 1
          fi

          # 6) 建立模組目的資料夾並複製
          mkdir -p "spk/atlantic/files/lib/modules/${KERNEL_VER}"
          if [ -f "${DRIVER_DIR}/${PKG_NAME}/atlantic.ko" ]; then
            install -D "${DRIVER_DIR}/${PKG_NAME}/atlantic.ko" "spk/atlantic/files/lib/modules/${KERNEL_VER}/atlantic.ko"
            echo "Kernel module copied successfully"
          else
            echo "::error::Kernel module not found: ${DRIVER_DIR}/${PKG_NAME}/atlantic.ko"
            exit 1
          fi

          # 7) 更新版本號
          sed -i "s/^SPK_VERS.*/SPK_VERS = ${PKG_VERSION}/" spk/atlantic/Makefile

      - name: 下載工具鏈 (一次性節省後續 cache)
        run: |
          cd spksrc
          make setup

      - name: 建置 .spk
        id: build-spk
        run: |
          # 1) 切換目錄
          cd spksrc
          # 2) TCVERSION - DSM 主版號 7.x, arch - CPU 架構
          TCVERSION=${DSM_TAG%-*}

          # 3) 映射架構名稱到 spksrc 格式
          # spksrc 使用具體的 CPU 架構名稱，而非通用名稱
          case "${CPU_SERIES}" in
            # DSM 7.2 CPU 系列
            "v1000")
              SPKSRC_ARCH="v1000"
              ;;
            "geminilake")
              SPKSRC_ARCH="geminilake"
              ;;
            "apollolake")
              SPKSRC_ARCH="apollolake"
              ;;
            "kvmx64")
              SPKSRC_ARCH="kvmx64"
              ;;
            "denverton")
              SPKSRC_ARCH="denverton"
              ;;
            "broadwell")
              SPKSRC_ARCH="broadwell"
              ;;
            "braswell")
              SPKSRC_ARCH="braswell"
              ;;
            "cedarview")
              SPKSRC_ARCH="cedarview"
              ;;
            "evansport")
              SPKSRC_ARCH="evansport"
              ;;
            "grantley")
              SPKSRC_ARCH="grantley"
              ;;
            "purley")
              SPKSRC_ARCH="purley"
              ;;
            "dockerx64")
              SPKSRC_ARCH="dockerx64"
              ;;
            # DSM 7.3 CPU 系列 (nk variants)
            "v1000nk")
              SPKSRC_ARCH="v1000nk"
              ;;
            "r1000nk")
              SPKSRC_ARCH="r1000nk"
              ;;
            "geminilakenk")
              SPKSRC_ARCH="geminilakenk"
              ;;
            *)
              # 對於未知的 CPU 系列，使用 CPU_SERIES 作為備用
              SPKSRC_ARCH="${CPU_SERIES}"
              ;;
          esac

          echo "SPKSRC_ARCH=${SPKSRC_ARCH}" >> $GITHUB_OUTPUT
          echo "Building with TCVERSION=${TCVERSION}, ARCH=${ARCH}, CPU_SERIES=${CPU_SERIES}, SPKSRC_ARCH=${SPKSRC_ARCH}"

          # List available targets to debug
          echo "Available make targets:"
          make help 2>/dev/null | head -20 || echo "No help target available"
          
          # Check if atlantic package exists
          if [ -f "spk/atlantic/Makefile" ]; then
            echo "Atlantic package Makefile found"
            ls -la spk/atlantic/
          else
            echo "Atlantic package Makefile not found"
            ls -la spk/ 2>/dev/null || echo "No spk directory"
          fi
          
          # Try to build using the spk directory approach
          echo "Trying to build using spk/atlantic target..."
          if make ARCH=${SPKSRC_ARCH} TCVERSION=${TCVERSION} spk/atlantic; then
            echo "spk/atlantic target succeeded"
            echo "Build completed successfully"
          else
            echo "spk/atlantic failed, trying other approaches..."
            # Try different target names
            echo "Trying spk-atlantic target..."
            if make ARCH=${SPKSRC_ARCH} TCVERSION=${TCVERSION} spk-atlantic; then
              echo "spk-atlantic target succeeded"
              echo "Build completed successfully"
            else
              echo "spk-atlantic failed, trying atlantic target..."
              if make ARCH=${SPKSRC_ARCH} TCVERSION=${TCVERSION} atlantic; then
                echo "atlantic target succeeded"
                echo "Build completed successfully"
              else
                echo "All build targets failed"
                echo "Checking make help for available targets..."
                make help 2>/dev/null | grep -i atlantic || echo "No atlantic targets found in help"
              fi
            fi
          fi

          # === 構建完成，檢查輸出 ===
          echo "=== Build Output Summary ==="
          echo "Package: ${PKG_NAME} ${PKG_VERSION}"
          echo "Device: ${DEVICE}"
          echo "CPU Series: ${CPU_SERIES}"
          echo "DSM Version: ${DSM_VER_FULL}"
          echo "Kernel: ${KERNEL_VER}"
          echo "Architecture: ${SPKSRC_ARCH}"
          echo "==========================="
          
          # 檢查輸出目錄
          echo "\nSearching for built SPK files..."
          find spksrc/output -name "*.spk" 2>/dev/null || echo "No .spk files in spksrc/output"
          find . -name "*atlantic*.spk" 2>/dev/null || echo "No atlantic SPK files found"
          
          # 列出可能的輸出位置
          echo "\nChecking possible output locations:"
          ls -la spksrc/output/${SPKSRC_ARCH}/ 2>/dev/null || echo "No output/${SPKSRC_ARCH}/ directory"
          ls -la spksrc/packages/*/target/ 2>/dev/null || echo "No packages/*/target/ directories"

      - name: 上傳產出的 .spk
        uses: actions/upload-artifact@v4
        with:
          name: "${{ env.PKG_NAME }}-${{ env.PKG_VERSION }}-${{ matrix.dsm_ver }}-${{ matrix.cpu_series }}_1"
          path: |
            spksrc/output/${{ steps.build-spk.outputs.SPKSRC_ARCH }}/*.spk
            spksrc/output/*/*.spk
            spksrc/packages/*/target/*.spk
            **/*atlantic*.spk
          if-no-files-found: warn
